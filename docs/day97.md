# 配列とポインタの違い

配列とポインタはパッと見同じ感じで書ける。
```cpp=
char s1[] = "array";
char* s2 = "pointer";
```
i個目のアイテムにアクセスしたい場合はどちらも`s[i]`というように書けばいいし、関数への渡し方なども同じ。  

でも中身は違う。

## 配列 vs ポインタ
ポインタはアドレスを格納している変数であり、その値をincrementしたり違う値に変えたりできる。  
ポインタが指す先は値として格納されていて、そのアドレス値を格納する領域が存在しているので、値の変更という概念がある。

一方配列は、配列の先頭アドレスを指す定数。  
メモリ領域は持たない。実体を持たないシンボル。  
なので名前の指す先が変わるというコンセプトがない。

## 具体例
以下のサンプルを確認する。
```cpp=
int main(void) {
	int a[] = {1};
	int i = 1;
	int* p = &i;
	std::cout << sizeof(a) << " " << a << " " << &a << std::endl;
	std::cout << sizeof(p) << " " << p << " " << &p << std::endl;
	return 0;
}
```

出力はこんな感じ
```
4 0x7fff4295c4dc 0x7fff4295c4dc
8 0x7fff4295c4d8 0x7fff4295c4d0
```


まず`sizeof`関数について。  
`a[]`のサイズは`4`で、`p`のサイズは`8`。  
ちなみに`int`はサイズ`4`で`int*`は`8` <- 64bits環境なので。  
`a`の方は配列そのもののサイズを返している一方、`p`はポインタのサイズを返している。


また`&`演算子について。  
これはアドレス演算子と呼ばれており、アドレスを返すとされているが、実際には「シンボルのアドレス」を返している。  
なので、指す先がない配列の`a`は`&a`と同じだが、ポインタの方は`p`と`&p`が違う。
